#! /usr/bin/env python
# -*- coding: utf-8 -*-
# vim:fenc=utf-8
#
"""
Skeleton for the Telephone.py script to go through multiple targets
"""
import click
from click_option_group import (
    optgroup,
    OptionGroup,
    RequiredMutuallyExclusiveOptionGroup,
)
import sys
import json
import requests
import uuid
import copy

sys.path.append("./clients")

from blaze_client import BlazeClient
from hapi_client import HapiClient
from ibm_fhir_client import IBMFHIRClient
from vista_client import VistaClient
import db

config = {
    "vista": ("http://localhost:8002", "api"),
    "ibm": ("https://localhost:8005", "fhir-server/api/v4"),
    "hapi": ("http://localhost:8004", "fhir"),
    "blaze": ("http://localhost:8006", "fhir"),
}

vista_client = VistaClient(config["vista"][0], config["vista"][1])
ibm_client = IBMFHIRClient(config["ibm"][0], config["ibm"][1])
hapi_client = HapiClient(config["hapi"][0], config["hapi"][1])
blaze_client = BlazeClient(config["blaze"][0], config["blaze"][1])

functions = {
    "vista": vista_client.step,
    "ibm": ibm_client.step,
    "hapi": hapi_client.step,
    "blaze": blaze_client.step,
}


def check_connection():
    """
    Send requests to all the servers to ensure they are up and returning 200s
    """
    clients = [vista_client, ibm_client, hapi_client, blaze_client]
    client_names = ["vista", "ibm", "hapi", "blaze"]
    for iterator, client in enumerate(map(lambda x: x.export_patients(), clients)):
        if client[0] != 200:
            print(f"{client_names[iterator]} server not up yet. Exiting.")
            sys.exit(1)
    neo4j_req = requests.get("http://localhost:7474")
    synthea_req = requests.get("http://localhost:9000/status")
    if neo4j_req.status_code != 200:
        print("neo4j server not up yet. Exiting.")
        sys.exit(1)
    if synthea_req.status_code != 200:
        print("synthea server not up yet. Exiting.")
        sys.exit(1)
    return True


def process_chain(guid, first_node, chain, file):
    """
    Given a chain, we iterate through the steps in it
    """
    for step_number, step in enumerate(chain):
        # First step is Synthea or File
        (error, file) = process_step(
            guid, first_node, step_number, step, chain, file, len(chain)
        )
        if error:
            print(f"Error encountered processing step {step_number}, node {step}")
            break


def dfs(guid, first_node, counter, step, chain, chain_length, file):
    """
    Run a depth-first search to compute all possible chains
    """
    error = False
    if len(chain) > 0:
        tmp_chain = copy.deepcopy(chain)
        if len(tmp_chain) != chain_length:
            tmp_chain = tmp_chain + (chain_length - len(tmp_chain)) * [step]
        (error, file) = process_step(
            guid, first_node, counter - 1, step, tmp_chain, file, chain_length
        )
    if counter > chain_length - 1:
        return
    if error:
        return
    for node in list(config.keys()):
        dfs(guid, first_node, counter + 1, node, chain + [node], chain_length, file)


def process_step(guid, first_node, step_number, step, chain, file, chain_length):
    """
    Process one entire step
    Checks if we got a patient id generated by ingesting a file. If not, we hit an error.
    """
    (patient_id, response_json_1, response_json_2) = functions[step](step_number, file)
    if patient_id is None:
        print(
            f"Chain terminated at step {step_number} {step} {response_json_1} {response_json_2}"
        )
        """
        Connection to this current node failed.
        So either this node could not ingest the file or could not export
        Either way, we create an edge to this node
        and another edge from this node to terminated
        Why: a JSON blob is returned when the node cannot ingest it
        This way we also know clearly where it failed
        """
        if step_number == 0:
            db.create_edge(guid, first_node, step, file)
            db.create_edge(guid, step, "termination", response_json_2)
        else:
            db.create_edge(guid, chain[step_number - 1], step, file)
            db.create_edge(guid, step, "termination", response_json_2)

        return (True, response_json_2)
        # We must not be terminating the entire run, just what cannot be reached after
    if step_number == chain_length - 1 and step_number == 0:
        # Last element
        db.create_edge(guid, first_node, step, file)
        db.create_edge(guid, step, "end", response_json_2)
    elif step_number == 0:
        """
        If its the first hop then we need to read the first_node field
        """
        db.create_edge(guid, first_node, step, file)
    elif step_number == chain_length - 1:
        # Last element
        db.create_edge(guid, chain[step_number - 1], step, file)
        db.create_edge(guid, step, "end", response_json_2)

    else:
        db.create_edge(guid, chain[step_number - 1], step, file)

    return (False, response_json_2)


chain_config = OptionGroup(
    "Configure all chains", help="How to configure all enumerated chains"
)


@click.command()
@click.option("--check-connections", "check_connections", is_flag=True, default=False)
@click.option("--chain-length", "chain_length", default=3, type=int)
@optgroup.group(
    "Either generate a file or provide a command-line argument",
    cls=RequiredMutuallyExclusiveOptionGroup,
    help="Group description",
)
@optgroup.option("--file", type=click.File("r"))
@optgroup.option("--generate", "generate", is_flag=True, default=False)
@optgroup.group(
    "Either use a chain or generate all chains",
    cls=RequiredMutuallyExclusiveOptionGroup,
    help="Group description",
)
@optgroup.option(
    "--chain",
    "-c",
    multiple=True,
    type=click.Choice(list(config.keys())),
)
@optgroup.option("--all-chains", "all_chains", is_flag=True, default=False)
def cli_options(check_connections, chain_length, file, generate, chain, all_chains):
    """Command line options for the telephone.py script
    Vista takes a different format (Bundle Resource) as input, whereas others require a patient
    """
    check_connection()  # Make sure all the images are up
    first_node = "file"  # By default assume that we are reading from a CLI file
    guid = str(uuid.uuid4())

    # Create nodes in the neo4j database for all the servers we use
    # It won't create duplicate nodes for the servers
    # We add additional nodes to denote the end of a chain and how many keys are present
    db.create_nodes(list(config.keys()) + ["synthea", "file", "end", "termination"])

    # Generate a new FHIR JSON file
    if file:
        file = file.read()
    if generate:
        first_node = "synthea"  # generated by Synthea, not a file read
        r = requests.get("http://localhost:9000/", timeout=100)
        if r.status_code == 200:
            filename = r.json()["filename"]
            # overwrite the file variable
            file = open(f"../files/fhir/{filename}").read()
            print(f"Successfully created file for {filename}")
        else:
            print("File creation failed from Synthea")
            sys.exit(1)

    if all_chains:
        # Traverse all the chains possible now
        dfs(guid, first_node, 0, "", [], chain_length, file)
    else:
        # all chains not specified, so we specified specific hops
        process_chain(guid, first_node, chain, file)


if __name__ == "__main__":
    cli_options()
